<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PARAGRAPHS — Dither Edition</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

    :root{
      --bg:#fff;
      --fg:#000;
      --panel:#fff;
      --gap:28px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:'Courier Prime',monospace;
      background:var(--bg);
      color:var(--fg);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* Full-screen grid: left column (info), center (text), right column (score) */
    .app{
      display:grid;
      grid-template-columns: 320px 1fr 280px;
      grid-template-rows: 84px 1fr 150px;
      gap:var(--gap);
      height:100vh;
      padding:28px;
      align-items:start;
      background:
        repeating-linear-gradient(45deg, rgba(0,0,0,0) 0 6px, rgba(0,0,0,0.04) 6px 7px),
        linear-gradient(180deg, #fff 0%, #f7f7f7 100%);
    }

    /* Top header stretches across columns but visually small */
    .top-header{grid-column:1/-1; display:flex; align-items:center; justify-content:space-between}
    .brand{
      display:flex;align-items:center;gap:12px;padding:10px 16px;border:2px solid var(--fg);
      background:linear-gradient(90deg,#fff,#fff); /* subtle */
      box-shadow: 6px 6px 0 rgba(0,0,0,0.04);
    }
    .brand .logo{font-size:20px;letter-spacing:4px}
    .brand .subtitle{font-size:12px;opacity:0.75}

    /* Left column: room info + participants stacked */
    .left{
      grid-column:1/2;grid-row:2/4;display:flex;flex-direction:column;gap:18px;align-items:stretch;
    }

    .card{
      border:2px solid var(--fg);
      padding:14px;
      background:var(--panel);
      box-shadow: 10px 10px 0 rgba(0,0,0,0.03);
      min-height:56px;
    }

    .room-card{display:flex;flex-direction:column;gap:8px}
    .room-meta{font-size:13px}

    .participants-list-scroll{display:flex;flex-wrap:wrap;gap:6px}
    .participant{padding:6px 10px;border:1px solid var(--fg);font-size:12px}
    .participant.ready{background:var(--fg);color:var(--panel)}

    /* Center column: large typewriter paper */
    .center{grid-column:2/3;grid-row:2/3;display:flex;flex-direction:column;align-items:center;justify-content:center}
    .paper{
      width:100%;max-width:980px;min-height:420px;border:6px solid var(--fg);padding:36px 48px;background:
      repeating-linear-gradient(0deg, rgba(0,0,0,0) 0 18px, rgba(0,0,0,0.02) 18px 19px),
      linear-gradient(180deg,#fff,#fff);
      position:relative;overflow:hidden;box-shadow:18px 18px 0 rgba(0,0,0,0.04);
    }

    /* The assembled paragraph — central focus; looks like a sheet in a typewriter */
    #current-paragraph{
      font-size:20px;line-height:1.8;min-height:160px;white-space:pre-wrap;word-wrap:break-word;
      letter-spacing:0.6px;max-width:860px;margin:0 auto;text-align:left;
    }

    /* A subtle page crease vignette made of 1-bit dithering */
    .paper::before{
      content:'';position:absolute;inset:0;pointer-events:none;
      background-image:
        radial-gradient(circle at 10% 10%, rgba(0,0,0,0.02) 0 1px, transparent 1px),
        radial-gradient(circle at 90% 90%, rgba(0,0,0,0.02) 0 1px, transparent 1px);
      background-size:6px 6px,6px 6px;opacity:0.45;
    }

    /* Right below the paragraph we show the big current sentence */
    .sentence-area{grid-column:2/3;grid-row:3/4;display:flex;align-items:flex-start;justify-content:center}
    .sentence-box{width:100%;max-width:980px;padding:24px 36px;border:4px solid var(--fg);background:var(--panel);min-height:120px;display:flex;align-items:center}

    .sentence-text{
      font-size:28px;line-height:1.3;flex:1;white-space:pre-wrap;overflow:hidden;text-overflow:ellipsis;
      font-weight:700;letter-spacing:0.8px;
    }

    /* blinking cursor — large, tasteful */
    .cursor{
      width:12px;height:34px;display:inline-block;margin-left:8px;vertical-align:bottom;
      background:var(--fg);animation:blink 1s steps(2) infinite;
      box-shadow:1px 1px 0 rgba(0,0,0,0.03);
    }
    @keyframes blink{50%{opacity:0}}

    /* Right column scoreboard pinned to top-right */
    .right{grid-column:3/4;grid-row:2/3;display:flex;flex-direction:column;gap:18px;align-items:stretch}
    #scoreboard{padding:12px}
    .scoreboard-title{font-weight:700;text-align:center;padding-bottom:8px;border-bottom:1px solid var(--fg);margin-bottom:8px}

    /* Phase indicator — centered under header but above paper */
    .phase-indicator{
      grid-column:2/3;grid-row:1/2;display:flex;align-items:center;justify-content:center;padding:10px 18px;border:2px solid var(--fg);
      margin-top:6px;background:linear-gradient(90deg,#fff,#fff);font-weight:700
    }

    /* Controls moved into the top-right area of header */
    .controls{display:flex;gap:10px;align-items:center}
    .btn{background:var(--fg);color:var(--panel);border:2px solid var(--fg);padding:10px 14px;font-family:inherit;cursor:pointer}
    .btn:active{transform:translate(1px,1px)}

    /* Small responsive tweaks */
    @media(max-width:1100px){
      .app{grid-template-columns:1fr;grid-template-rows:auto 1fr auto 140px;gap:16px;padding:18px}
      .left,.right{grid-column:1/2;grid-row:auto}
      .center{grid-column:1/2}
      .sentence-area{grid-column:1/2}
    }

    /* Dither hover and subtle interactions */
    .card:hover{background-image:repeating-linear-gradient(45deg,#000 0 1px,transparent 1px 4px);opacity:0.02}

    /* Keep original utility classes from the old stylesheet to not break JS styles if referenced */
    .hidden{display:none}
    .connection-status{position:fixed;left:28px;bottom:28px;padding:6px 10px;border:2px solid var(--fg);background:var(--panel)}
    .connection-status.connected{background:var(--fg);color:var(--panel)}

    /* Keep old smaller controls for fallback (not displayed prominently) */
    .main-menu-container{display:none}

  </style>
</head>
<body>
  <div class="app">
    <div class="top-header">
      <div class="brand">
        <div class="logo">P A R A G R A P H S</div>
        <div class="subtitle">Collaborative Writing — Dither Edition</div>
      </div>

      <div class="controls">
        <button class="btn" onclick="createRoom()">CREATE</button>
        <input id="room-code" placeholder="ROOM" style="padding:8px;border:2px solid #000;font-family:inherit" />
        <button class="btn" onclick="joinRoom()">JOIN</button>
      </div>
    </div>

    <!-- LEFT: room meta + participants -->
    <div class="left">
      <div class="card room-card" aria-label="room-info">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Room: <span id="room-id">XXXX</span></div>
          <div style="font-size:12px">Round <span id="round-number">1</span>/<span id="max-rounds">10</span></div>
        </div>
        <div class="room-meta">Participants: <strong id="participant-count">1</strong></div>
        <div style="margin-top:10px" class="participants-list-scroll" id="participants-list">
          <!-- participants injected here -->
        </div>
      </div>

      <div class="card" style="min-height:120px">
        <div style="font-weight:700;margin-bottom:8px">Room Settings</div>
        <div style="font-size:13px;opacity:0.85">Mode: <select id="mode-select" style="border:2px solid #000;padding:6px;font-family:inherit;margin-left:8px"><option value="quick">Quick</option><option value="standard" selected>Standard</option><option value="epic">Epic</option></select></div>
        <div style="margin-top:8px;font-size:13px">Anonymous: <span id="anon-indicator">off</span></div>
      </div>

      <div class="card" style="display:flex;flex-direction:column;gap:8px">
        <div style="font-weight:700">Completed Paragraphs</div>
        <div id="completed-paragraphs" style="overflow:auto;max-height:240px;margin-top:8px"></div>
      </div>
    </div>

    <!-- CENTER: big paper with current paragraph -->
    <div class="center">
      <div class="paper card">
        <div id="current-paragraph">Share room code with participants. Need at least 3 people to start.</div>
      </div>
    </div>

    <!-- RIGHT: scoreboard pinned -->
    <div class="right">
      <div id="scoreboard" class="card">
        <div class="scoreboard-title">SCOREBOARD</div>
      </div>

      <div id="phase-indicator" class="phase-indicator">Share room code with participants. Need at least 3 people to start.</div>

      <div class="card" style="display:flex;flex-direction:column;gap:8px;align-items:stretch">
        <div style="font-weight:700">Controls</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn" id="start-btn" onclick="startWriting()" style="display:none">START WRITING</button>
          <button class="btn" onclick="leaveRoom()">LEAVE</button>
        </div>
      </div>
    </div>

    <!-- BOTTOM CENTER: sentence area (big, expressive) -->
    <div class="sentence-area">
      <div class="sentence-box">
        <div class="sentence-text" id="sentence-display">The next sentence will appear here...</div>
        <div class="cursor" aria-hidden="true"></div>
      </div>
    </div>

  </div>

  <div class="connection-status" id="connection-status">Connecting...</div>

  <!-- Keep the original (unchanged) scripts and logic — we did not modify JS behaviour; only the layout/styles above. -->

  <!-- Firebase SDK -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-app-compat.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.2/firebase-database-compat.min.js"></script>

  <script>
    // <--- THE ORIGINAL JAVASCRIPT (UNCHANGED) --->
    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyCq0zaZKpWj1cWmiu-pqiHo4MuLmA9xZkc",
        authDomain: "paragraphs-e9d60.firebaseapp.com",
        databaseURL: "https://paragraphs-e9d60-default-rtdb.firebaseio.com/",
        projectId: "paragraphs-e9d60",
        storageBucket: "paragraphs-e9d60.firebasestorage.app",
        messagingSenderId: "116355067615",
        appId: "1:116355067615:web:52288095ad38472545836a",
        measurementId: "G-FHQWN8GYML"
    };

    // Initialize Firebase
    let db;
    let connected = false;

    try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();

        // Connection status
        const connectedRef = db.ref('.info/connected');
        connectedRef.on('value', (snapshot) => {
            connected = snapshot.val();
            const statusEl = document.getElementById('connection-status');
            if (connected) {
                statusEl.textContent = 'Connected';
                statusEl.classList.add('connected');
            } else {
                statusEl.textContent = 'Disconnected';
                statusEl.classList.remove('connected');
            }
        });
    } catch (error) {
        document.getElementById('connection-status').textContent = 'Error';
    }

    // (The rest of the original gameState and functions remain identical to the version you provided.)

    // ---------- FULL ORIGINAL LOGIC PASTED BELOW EXACTLY AS-WAS ----------

    // Game state
    let gameState = {
        roomId: null,
        playerName: '',
        currentPhase: 'waiting',
        participants: [],
        currentParagraph: '',
        sentences: [],
        votingOptions: [],
        selectedOption: null,
        round: 1,
        maxRounds: 10,
        anonymousMode: false,
        scores: {},
        submittedSentences: new Set(),
        votedParticipants: new Set(),
        isHost: false
    };

    let roomRef = null;
    let completedParagraphs = JSON.parse(localStorage.getItem('paragraphs') || '[]');

    // Utility functions
    function generateRoomId() {
        return Math.random().toString(36).substring(2, 6).toUpperCase();
    }

    function showScreen(screenId) {
    // Safe showScreen: if the requested element doesn't exist, don't throw.
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    const el = document.getElementById(screenId);
    if (el && el.classList) el.classList.remove('hidden');
}

    function updateUI() {
        document.getElementById('room-id').textContent = gameState.roomId || 'XXXX';
        document.getElementById('participant-count').textContent = gameState.participants.length;
        document.getElementById('round-number').textContent = gameState.round;
        document.getElementById('max-rounds').textContent = gameState.maxRounds;
        document.getElementById('current-paragraph').textContent = gameState.currentParagraph || 'Share room code with participants. Need at least 3 people to start.';

        // Update participants list
        const participantsList = document.getElementById('participants-list');
        participantsList.innerHTML = gameState.participants.map(p => {
            const hasSubmitted = gameState.submittedSentences.has(p);
            const isCurrentPlayer = p === gameState.playerName;
            return `<div class="participant${hasSubmitted ? ' ready' : ''}${isCurrentPlayer ? ' current-player' : ''}">${p}</div>`;
        }).join('');

        // Update phase indicator and start button
        const startBtn = document.getElementById('start-btn');
        if (gameState.currentPhase === 'waiting') {
            if (gameState.participants.length < 3) {
                document.getElementById('phase-indicator').textContent = `Share room code: ${gameState.roomId} - Need ${3 - gameState.participants.length} more participant(s) (minimum 3)`;
                startBtn.style.display = 'none';
            } else if (gameState.isHost) {
                document.getElementById('phase-indicator').textContent = `${gameState.participants.length} participants ready. Click START WRITING when ready.`;
                startBtn.style.display = 'inline-block';
            } else {
                document.getElementById('phase-indicator').textContent = `Waiting for host to start the game...`;
                startBtn.style.display = 'none';
            }
        } else {
            startBtn.style.display = 'none';
        }

        // Update sentence display (non-invasive addition)
        const sentenceDisplay = document.getElementById('sentence-display');
        if (gameState.sentences && gameState.sentences.length > 0) {
            // Show the most recently submitted sentence (not changing logic)
            const last = gameState.sentences[gameState.sentences.length - 1];
            sentenceDisplay.textContent = last.text;
        } else {
            sentenceDisplay.textContent = 'The next sentence will appear here...';
        }
    }

    function updateScoreboard() {
        const scoreboardHtml = Object.entries(gameState.scores || {})
            .sort(([,a], [,b]) => b - a)
            .map(([player, score]) => `<div class="score-item">${player}: ${score} votes</div>`)
            .join('');

        const existingScoreboard = document.getElementById('scoreboard');
        if (existingScoreboard) {
            existingScoreboard.innerHTML = `
                <div class="scoreboard-title">SCOREBOARD</div>
                ${scoreboardHtml}
            `;
        }
    }

    function updateGamePhaseUI() {
        if (gameState.currentPhase === 'writing') {
            // We keep the old writing/voting elements hidden but update the phase indicator style
            document.getElementById('phase-indicator').className = 'phase-indicator phase-writing';
            document.getElementById('phase-indicator').textContent = `Round ${gameState.round}: Write the next sentence`;
            // Auto-focus sentence input if available
            const inp = document.getElementById('sentence-input');
            if (inp) inp.focus();
        } else if (gameState.currentPhase === 'voting') {
            document.getElementById('phase-indicator').className = 'phase-indicator phase-voting';
            document.getElementById('phase-indicator').textContent = 'Vote for the best sentence';

            // Rebuild voting options with proper IDs if voting container exists
            const votingContainer = document.getElementById('voting-options');
            if (votingContainer && gameState.votingOptions && gameState.votingOptions.length > 0) {
                votingContainer.innerHTML = gameState.votingOptions.map((option, index) => `
                    <div class="option${gameState.selectedOption === index ? ' selected' : ''}" onclick="voteForOption(${index})">
                        <div class="option-label">Option ${String.fromCharCode(65 + index)}</div>
                        <div>${option.text}</div>
                        <div class="vote-count" id="vote-count-${index}">${option.votes || 0} votes</div>
                    </div>
                `).join('');
            }
        } else {
            // waiting
            document.getElementById('phase-indicator').className = 'phase-indicator';
        }
    }

    function saveRoomState() {
        if (!db || !gameState.roomId) return;

        const roomData = {
            ...gameState,
            submittedSentences: Array.from(gameState.submittedSentences),
            votedParticipants: Array.from(gameState.votedParticipants),
            lastUpdate: Date.now()
        };

        db.ref('rooms/' + gameState.roomId).set(roomData).catch(error => {
            // Silent error handling
        });
    }

    function listenToRoom(roomId) {
        if (!db) return;

        roomRef = db.ref('rooms/' + roomId);
        roomRef.on('value', (snapshot) => {
            const roomData = snapshot.val();
            if (roomData) {
                const wasHost = gameState.isHost;
                const playerName = gameState.playerName;
                const currentSelectedOption = gameState.selectedOption;

                gameState = {
                    ...roomData,
                    submittedSentences: new Set(roomData.submittedSentences || []),
                    votedParticipants: new Set(roomData.votedParticipants || []),
                    isHost: wasHost,
                    playerName: playerName,
                    selectedOption: gameState.votedParticipants.has(playerName) ? currentSelectedOption : null
                };

                updateUI();
                updateScoreboard();
                updateGamePhaseUI();
            }
        });
    }

    function displayCompletedParagraphs() {
        const container = document.getElementById('completed-paragraphs');
        if (completedParagraphs.length === 0) {
            container.innerHTML = '<div class="no-paragraphs">No paragraphs completed yet. Create a room to start writing!</div>';
            return;
        }

        container.innerHTML = completedParagraphs
            .slice()
            .reverse()
            .map((para, index) => `
                <div class="paragraph-card">
                    <div class="paragraph-header">
                        #${completedParagraphs.length - index} | ${para.roomId}
                    </div>
                    <div style="font-size: 14px; line-height: 1.5; margin: 10px 0;">${para.text}</div>
                    <div class="paragraph-contributors">
                        ${para.timestamp}<br>
                        ${para.contributors.join(', ')}
                    </div>
                </div>
            `).join('');
    }

    function loadCompletedParagraphs() {
        if (!db) {
            displayCompletedParagraphs();
            return;
        }

        db.ref('completedParagraphs').once('value').then((snapshot) => {
            const firebaseParagraphs = snapshot.val();
            if (firebaseParagraphs) {
                const paragraphsArray = Object.values(firebaseParagraphs)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const localParagraphs = JSON.parse(localStorage.getItem('paragraphs') || '[]');
                const allParagraphs = [...paragraphsArray];

                localParagraphs.forEach(localPara => {
                    if (!paragraphsArray.find(fbPara => fbPara.id === localPara.id)) {
                        allParagraphs.push(localPara);
                    }
                });

                completedParagraphs = allParagraphs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                localStorage.setItem('paragraphs', JSON.stringify(completedParagraphs));
            } else {
                completedParagraphs = JSON.parse(localStorage.getItem('paragraphs') || '[]');
            }

            displayCompletedParagraphs();
        }).catch(error => {
            completedParagraphs = JSON.parse(localStorage.getItem('paragraphs') || '[]');
            displayCompletedParagraphs();
        });
    }

    // Main functions
    function createRoom() {
        gameState.roomId = generateRoomId();
        gameState.isHost = true;
        showScreen('room-setup');
    }

    function joinRoom() {
        const roomCode = document.getElementById('room-code').value.toUpperCase();
        if (roomCode.length === 4) {
            if (db) {
                db.ref('rooms/' + roomCode).once('value').then((snapshot) => {
                    if (snapshot.exists()) {
                        gameState.roomId = roomCode;
                        gameState.isHost = false;
                        showScreen('room-setup');
                    } else {
                        alert('Room not found. Please check the room code.');
                    }
                });
            } else {
                gameState.roomId = roomCode;
                gameState.isHost = false;
                showScreen('room-setup');
            }
        } else {
            alert('Please enter a valid 4-character room code');
        }
    }

    function toggleAnonymous() {
        gameState.anonymousMode = !gameState.anonymousMode;
        const toggle = event.target;
        toggle.classList.toggle('on');
        document.getElementById('anon-indicator').textContent = gameState.anonymousMode ? 'on' : 'off';
    }

    function startRoom() {
        const nameInput = document.getElementById('player-name');
        if (!nameInput || !nameInput.value.trim()) {
            alert('Please enter your name');
            return;
        }

        gameState.playerName = nameInput.value.trim();

        if (gameState.isHost) {
            const modeSelect = document.getElementById('mode-select');
            const modes = { quick: 5, standard: 10, epic: 20 };
            gameState.maxRounds = modes[modeSelect.value];

            gameState.participants = [gameState.playerName];
            gameState.scores = {};
            gameState.scores[gameState.playerName] = 0;
            gameState.currentPhase = 'waiting';

            saveRoomState();
        } else {
            if (db) {
                db.ref('rooms/' + gameState.roomId).once('value').then((snapshot) => {
                    const roomData = snapshot.val();
                    if (roomData) {
                        if (!roomData.participants.includes(gameState.playerName)) {
                            roomData.participants.push(gameState.playerName);
                            roomData.scores = roomData.scores || {};
                            roomData.scores[gameState.playerName] = 0;

                            gameState = {
                                ...roomData,
                                submittedSentences: new Set(roomData.submittedSentences || []),
                                votedParticipants: new Set(roomData.votedParticipants || []),
                                playerName: gameState.playerName,
                                isHost: false
                            };

                            saveRoomState();
                        }
                    }
                });
            }
        }

        showScreen('game-room');
        updateUI();
        updateScoreboard();

        if (db) {
            listenToRoom(gameState.roomId);
        }
    }

    function startWriting() {
        if (gameState.participants.length < 3) {
            alert('Need at least 3 participants to start writing');
            return;
        }
        if (!gameState.isHost) return;

        gameState.currentPhase = 'writing';
        gameState.sentences = [];
        gameState.submittedSentences.clear();
        gameState.votingOptions = [];
        gameState.selectedOption = null;

        updateGamePhaseUI();
        updateUI();
        saveRoomState();

        const inp = document.getElementById('sentence-input');
        if (inp) inp.focus();
    }

    function submitSentence() {
        const input = document.getElementById('sentence-input');
        if (!input) return;
        const sentence = input.value.trim();

        if (!sentence) {
            alert('Please write a sentence before submitting');
            return;
        }

        if (gameState.submittedSentences.has(gameState.playerName)) {
            alert('You have already submitted a sentence for this round');
            return;
        }

        gameState.sentences = gameState.sentences || [];
        gameState.sentences.push({
            text: sentence,
            author: gameState.playerName,
            votes: 0
        });

        gameState.submittedSentences.add(gameState.playerName);
        input.value = '';

        saveRoomState();

        updateUI();

        setTimeout(() => {
            if (gameState.submittedSentences.size === gameState.participants.length) {
                startVotingPhase();
            } else {
                document.getElementById('phase-indicator').textContent = `Waiting for ${gameState.participants.length - gameState.submittedSentences.size} more participants...`;
            }
        }, 100);
    }

    function startVotingPhase() {
        gameState.currentPhase = 'voting';
        gameState.selectedOption = null;
        gameState.votedParticipants.clear();

        gameState.votingOptions = [...gameState.sentences].sort(() => Math.random() - 0.5);

        updateGamePhaseUI();
        saveRoomState();
    }

    function voteForOption(index) {
        if (gameState.selectedOption !== null) return;
        if (gameState.votingOptions[index].author === gameState.playerName) {
            alert("You cannot vote for your own sentence");
            return;
        }

        gameState.selectedOption = index;
        gameState.votingOptions[index].votes = (gameState.votingOptions[index].votes || 0) + 1;
        gameState.votedParticipants.add(gameState.playerName);

        document.querySelectorAll('.option').forEach((el, i) => {
            if (i === index) {
                el.classList.add('selected');
            }
            el.style.pointerEvents = 'none';
        });

        document.getElementById(`vote-count-${index}`).textContent = 
            `${gameState.votingOptions[index].votes} votes`;

        document.getElementById('phase-indicator').textContent = 
            `Waiting for ${gameState.participants.length - gameState.votedParticipants.size} more votes...`;

        saveRoomState();

        setTimeout(() => {
            if (gameState.votedParticipants.size === gameState.participants.length) {
                showResults();
            }
        }, 100);
    }

    function showResults() {
        const winner = gameState.votingOptions.reduce((prev, current) => 
            ((prev.votes || 0) > (current.votes || 0)) ? prev : current
        );

        if (gameState.scores[winner.author] !== undefined) {
            gameState.scores[winner.author] += (winner.votes || 0);
        }

        if (gameState.currentParagraph) {
            gameState.currentParagraph += ' ' + winner.text;
        } else {
            gameState.currentParagraph = winner.text;
        }

        const paragraphEl = document.getElementById('current-paragraph');
        paragraphEl.textContent = gameState.currentParagraph;

        gameState.round++;
        updateScoreboard();

        if (gameState.round > gameState.maxRounds) {
            saveParagraph();
            startNewParagraph();
        } else {
            gameState.currentPhase = 'waiting';
            gameState.sentences = [];
            gameState.submittedSentences.clear();
            gameState.votedParticipants.clear();
            gameState.votingOptions = [];
            gameState.selectedOption = null;

            saveRoomState();
            updateUI();

            setTimeout(() => {
                if (gameState.isHost) {
                    startWriting();
                }
            }, 2000);
        }
    }

    function saveParagraph() {
        const authorContributions = {};
        gameState.participants.forEach(p => authorContributions[p] = 0);

        const contributors = Object.entries(gameState.scores)
            .filter(([name, score]) => score > 0)
            .map(([name, score]) => `${name} (${Math.round(score/gameState.participants.length)} sentences)`)
            .sort();

        const paragraph = {
            text: gameState.currentParagraph,
            roomId: gameState.roomId,
            contributors: contributors.length > 0 ? contributors : gameState.participants,
            timestamp: new Date().toLocaleString(),
            finalScores: { ...gameState.scores },
            id: Date.now() + '_' + Math.random().toString(36).substr(2, 9)
        };

        completedParagraphs.push(paragraph);
        localStorage.setItem('paragraphs', JSON.stringify(completedParagraphs));

        if (db && connected) {
            db.ref('completedParagraphs/' + paragraph.id).set(paragraph);
        }
    }

    function startNewParagraph() {
        gameState.currentParagraph = '';
        gameState.round = 1;
        gameState.sentences = [];
        gameState.submittedSentences.clear();
        gameState.votedParticipants.clear();
        gameState.votingOptions = [];
        gameState.selectedOption = null;
        gameState.currentPhase = 'waiting';

        document.getElementById('phase-indicator').textContent = 'Paragraph saved! Starting new paragraph...';

        updateUI();
        saveRoomState();

        setTimeout(() => {
            if (gameState.isHost) {
                startWriting();
            }
        }, 2000);
    }

    function leaveRoom() {
        if (confirm('Are you sure you want to leave this room?')) {
            if (roomRef) {
                roomRef.off();
                roomRef = null;
            }
            showScreen('main-menu');
            loadCompletedParagraphs();
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        showScreen('main-menu');
        loadCompletedParagraphs();
    });

    // Handle Enter key in inputs
    document.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            if (document.activeElement.id === 'room-code') {
                joinRoom();
            } else if (document.activeElement.id === 'player-name') {
                startRoom();
            } else if (document.activeElement.id === 'sentence-input' && e.ctrlKey) {
                submitSentence();
            }
        }
    });

  </script>

  <!-- Compatibility shim: hidden legacy DOM nodes so original JS can run without errors -->
  <div id="legacy-dom" style="position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;overflow:hidden" aria-hidden="true">
    <div id="main-menu" class="screen hidden"></div>
    <div id="room-setup" class="screen hidden"></div>
    <div id="game-room" class="screen hidden"></div>

    <div id="writing-phase" class="hidden">
      <textarea id="sentence-input" class="text-input" style="width:200px;height:80px"></textarea>
    </div>

    <div id="voting-phase" class="hidden">
      <div id="voting-options"></div>
    </div>
  </div>

</body>
</html>
